    SELECT * 
    FROM TAB;

## LEAD AND LAG--> WINDOW FUNCTIONS    

## LAG
- It is used to look backward of the previous one.

## Syntax-
    LAG(COL_NAME)OVER(PARTITION BY COL_NAME ORDER BY COL_NAME ASC/DESC)


    SELECT CHOCO.*,LAG(TSALES) OVER(ORDER BY MID)AS PREV_MONTH
    TSALES-LAG(TSALES,2) OVER(ORDER BY MID) AS DIFF
    FROM CHOCO;    

    SELECT CHOCO.*,LAG(TSALES) OVER(ORDER BY MID)AS PREV_MONTH
    TSALES-LAG(TSALES,2) OVER(ORDER BY MID) AS DIFF
    FROM CHOCO;    

#### WAQTD the sal difference between previous employee and current employee and also print all the employee details.

    SELECT EMP.*,SAL-LAG(SAL)OVER(ORDER BY SAL)AS DIFF
    FROM EMP;

    SELECT EMP.*,SAL-LEAD(SAL)OVER(ORDER BY SAL)AS DIFF
FROM EMP;

#### WAQTD the each employees salary and previous employee sal in the same dept.

    SELECT EMP.*,LAG(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL)AS DIFF 
    FROM EMP;    
---

## LEAD-->
- It is used it to looked Forward (Upcoming ROW).

### Syntax :-
    
    LEAD(COL_NAME)OVER(PARTITION BY COL_NAME ORDER BY COL_NAME ASC/DESC)

#### WAQTD the emp details along with sal difference between current employee and next employee.
    
    SELECT EMP.*,SAL-LEAD(SAL) OVER(ORDER BY SAL)AS DIFF
    FROM EMP;
---

## CASE FUNCTION() -->

    CASE
    WHEN 'CONDITION' THEN'PRINT'
    WHEN 'CONDITION' THEN'PRINT'
    WHEN 'CONDITION' THEN'PRINT'
    .
    .
    END

EMP>2500-->EXCELLENT
EMP<=2500--> GOOD
EMP<1000 --> BAD

    SELECT ENAME,SAL,CASE
    WHEN SAL>2500 THEN 'EXCELLENT'
    WHEN SAL<=2500 AND SAL>=1000 THEN 'GOOD'
    WHEN SAL<1000 THEN 'BAD'
    END
    FROM EMP;

#### P1. <I>WAQTD THE ALL THE DETAILS OF THE EMPLOYEE ALONG WITH 25% HIKE IN ANNUAL SAL IF THE EMPLOYEE NAMES HAVE A CHARACTER 'A' IN THEIR NAME AND WORK IN DEPT 10 OR 30 AS A SALESMAN OR MANAGER AND HIRED ON WEDNESDAY AND ALSO PRINT THE NO OF EXPERIENCE THE EMPLOYEES HAVE FROM THE HIREDATE TO TILL DATE AND SHOW IN YEARS.</I>   

    SELECT EMP.*,SAL*12+SAL*12*25/100, MONTHS_BETWEEN(SYSDATE, HIREDATE)/12 AS YRS_OF_EXP
    FROM EMP
    WHERE ENAME LIKE '%A%' AND DEPTNO IN(10,30) AND JOB IN('SALESMAN','MANAGER') AND TO_CHAR(HIREDATE,'DY')='WED';

    SELECT EMP.*, 
    CASE 
    WHEN ENAME LIKE '%A%' AND DEPTNO IN (10,30) AND JOB IN ('SALESMAN','MANAGER') AND TO_CHAR(HIREDATE,'DY')='WED' 
    THEN SAL*1.25 
    ELSE SAL 
    END AS NEW_SAL,
    TRUNC(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12) AS EXPERIENCE_YEARS
    FROM EMP;

#### P2. WAQTD THE DEPT DETAILS OF THE EMPLOYEE WHOSE NAMES LAST CHARACTER ARE THE SAME

EXAMPLE
MILLER = TURNER 

    SELECT *
    FROM DEPT
    WHERE DEPTNO IN(SELECT DISTINCT E1.DEPTNO
    FROM EMP E1)


    SELECT COUNT(*),JOB
    FROM EMP
    WHERE JOB= 'SALESMAN'
    GROUP BY JOB
    HAVING COUNT(*) BETWEEN 2 AND 6;               

    

#### P3.WAQTD THE DEPT DETAILS OF THE EMPLOYEES WHO ARE HIRED ON THE SAME DATE

    SELECT D1.*
    FROM DEPT D1,EMP E1
    WHERE E1.DEPTNO=D1.DEPTNO
    AND E1.HIREDATE IN (SELECT E2.HIREDATE
    FROM EMP E2
    GROUP BY E2.HIREDATE
    HAVING COUNT(*)>1);

#### P4.WAQTD THE NO OF EMPLOYEES WORKING IN EACH LOC AND THEIR LOC HAS A CHARACTER 'O' IN THEIR NAME

    SELECT COUNT(*), LOC
    FROM EMP, DEPT
    WHERE EMP.DEPTNO = DEPT.DEPTNO AND LOC LIKE '%O%'
    GROUP BY LOC;

#### P5.WAQTD THE EMP NAME, MGR NAME, MGR'S MGR NAME IF THE EMPLOYEE EARNS MORE THAN 2 MIN SAL AND MANAGER'S MGR EARNS MORE THAN SMITH'S MANAGER    




---X---

    SELECT E1.ENAME AS EMP_NAME,
    E2.ENAME AS MGR_NAME,
    E3.ENAME AS MGR_MGR_NAME
    FROM EMP E1
    LEFT JOIN EMP E2 ON E1.MGR=E2.EMPNO
    LEFT JOIN EMP E3 ON E2.MGR=E3.EMPNO
    WHERE E1.SAL > (SELECT MIN(SAL) * 2 FROM EMP)
    AND E2.SAL > (SELECT SAL FROM EMP WHERE ENAME='SMITH');

#### P6. WAQTD THE JOB WISE TOP 2 SAL
   
    SELECT *
    FROM (SELECT EMP.*,DENSE_RANK() OVER (PARTITION BY    JOB ORDER BY SAL DESC) AS RANKING
    FROM EMP)
    WHERE RANKING <=2;

#### P7. WAQTD THE DETAILS OF THE EMPLOYEES ALONG WITH MAX SAL, MIN SAL, SUM COMM
---

    SELECT EMP.*,
    MAX(SAL) OVER() AS MAX_SAL,
    MIN(SAL) OVER() AS MIN_SAL,
    SUM(COMM) OVER() AS TOTAL_COMM
    FROM EMP;